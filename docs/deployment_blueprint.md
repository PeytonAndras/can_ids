# RAMN + CARLA Unsupervised IDS Deployment Blueprint

## Objectives
- Detect anomalous CAN activity on the RAMN vehicle testbed while running CARLA driving scenarios.
- Reuse the offline feature pipeline (`scripts/feature_extractor_can_ids.py`) and trained models generated by `scripts/train_unsupervised.py`.
- Deliver alerts with <=1 false positive every 10 minutes and <400 ms detection latency for injected attacks, matching the research plan.

## End-to-End Flow
1. **CAN Ingestion Layer**
   - Source: `python-can` interface connected to RAMN (socketCAN on `can0` when bridged via USB/CAN adapter).
   - Mirror CARLA traffic by replaying or simulating via bridge node; all frames funnel into the same listener.
   - Output: raw CAN frames (timestamp, arbitration ID, DLC, payload bytes).

2. **Window Aggregator**
   - Maintains rolling buffers for configurable windows (default 100 ms, supports 50/200 ms via CLI flag).
   - Emits a feature-ready DataFrame for each completed window.
   - Retains partial state for smoothing and latency calculations.

3. **Feature Extractor**
   - Reuses the feature set from offline training: frame counts, unique IDs, entropy, timing stats, payload byte statistics.
   - Implementation: shared helper imported from new deployment script (`compute_window_features(buffer)` mirroring `feature_extractor_can_ids.py`).
   - Output: single-row feature vector aligned with the scaler/model feature order stored in the model artifact bundle.

4. **Scoring Engine**
   - Loads artifacts produced by the refactored training pipeline:
     - `models/unsupervised/<dataset>/isolation_forest.joblib`
     - optional `pca_reconstruction.joblib` or `autoencoder.joblib`
     - matching scaler + `results/unsupervised/<dataset>/thresholds.json`
   - Applies `StandardScaler` transform and computes detector scores per window.
   - Calculates alert flag when score ≥ threshold; supports logical AND/OR ensemble strategies.

5. **Temporal Smoothing + Alert Manager**
   - Default smoothing: require 2 consecutive anomalous windows (≈200 ms) before emitting alert.
   - Alert payload: start/end timestamps, detector scores, threshold, top contributing feature deltas (computed via z-score vs baseline median/iqr statistics pre-loaded during startup).
   - Outputs to stdout, rotating JSON log, and optional MQTT/REST hook for RAMN dashboard.

6. **Telemetry & Health Monitoring**
   - Maintain counters for windows processed, FP/hour estimate, last alert time.
   - Expose metrics via simple HTTP `/metrics` endpoint (optional) for CARLA control scripts to consume.

## Component Responsibilities & Interfaces
| Component | Responsibilities | Inputs | Outputs |
|-----------|-----------------|--------|---------|
| `CanStream` | Connect to socketCAN / PCAN interface, normalize frames, enqueue for aggregation. | CAN frames | `(timestamp, id, dlc, data)` tuples |
| `WindowBuilder` | Assign frames to windows, flush complete windows, maintain overlap state. | Frame stream | Frame batches grouped by window |
| `FeatureEncoder` | Compute statistical features, ensure column alignment, handle NaNs. | Completed window batch | Feature vector (`pd.Series`) |
| `ModelEnsemble` | Load joblib artifacts, scale features, compute scores, fetch thresholds. | Feature vector | `dict(detector -> score)` |
| `DecisionLogic` | Apply thresholds, smoothing hysteresis, track ongoing alerts. | Detector scores + thresholds | Alert decision (bool) + context |
| `AlertSink` | Persist alerts and metrics to logs, optional network sinks. | Alert context | JSON log, console, optional telemetry |

## Configuration Schema
Create `deployment/config.yaml` (to be generated with the deployment script) containing:
```yaml
window_ms: 100
smoothing:
  consecutive_windows: 2
models:
  isolation_forest: models/unsupervised/processed/isolation_forest.joblib
  pca: models/unsupervised/processed/pca_reconstruction.joblib
scaler: models/unsupervised/processed/isolation_forest.joblib  # scaler bundled with joblib
thresholds: results/unsupervised/processed/thresholds.json
ensemble: logical_and  # options: isolation_forest, pca, logical_and, logical_or
logging:
  path: deployment/logs/alerts.jsonl
  level: INFO
telemetry:
  http_port: 8080
```

## Assumptions & Dependencies
- `python-can>=4.3` available in deployment environment.
- RAMN CAN interface exposed as `can0` using SocketCAN; CARLA scenarios publish CAN traffic either via RAMN firmware or bridge service.
- `joblib`, `numpy`, `pandas`, `sklearn` installed (same versions as training environment).
- Feature schema identical between training data and live stream (same window size and byte stats).

## Next Steps
1. Implement `scripts/deploy_realtime.py` honoring this blueprint.
2. Generate `deployment/config.yaml` template and include in repo (with data paths pointing to models/thresholds already committed).
3. Add README section covering setup (`pip install -r requirements-deploy.txt`), running the script, and expected outputs.
4. Validate on recorded RAMN benign drive, confirm FP/hour < threshold, then run attack replays for latency measurement.
